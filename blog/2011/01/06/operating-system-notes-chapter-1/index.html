
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Operating Systems Notes [Chapter 1] - liwanag</title>
  <meta name="author" content="nadine a.">

  
  <meta name="description" content="What is an operating system?An operating system is a program that manages computer hardware, as well as providing a basis for application programs. &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://neauro.github.io/blog/2011/01/06/operating-system-notes-chapter-1">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="liwanag" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<!-- <link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->
<link href="http://fonts.googleapis.com/css?family=Metrophobic:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-46467190-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body    class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">liwanag</a></h1>
  
    <h2>things i learn, things i like</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:neauro.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/about">About</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Operating Systems Notes [Chapter 1]</h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-01-06T00:00:00-08:00" pubdate data-updated="true">Jan 6<span>th</span>, 2011</time>
        
      </p>
    
  </header>


<div class="entry-content"><div class='post'>
<span class="sig">What is an operating system?</span><br />An <strong>operating system</strong> is a program that manages computer hardware, as well as providing a basis for application programs.  There are a variety of types of operating systems, not all of them for making it easy for a user to use games or software on a computer &#8211; for instance, you might have a mainframe operating system, which is an OS designed to optimize utilization of hardware.<br /><br />Computers are broken up into 4 &#8220;layers:&#8221;<br /><ul><li><em>Hardware.</em> The central processing unit (CPU), the memory, the input/output devices (like a keyboard, mouse)</li><li><em>Application programs.</em>  The programs you use on your computer &#8211; word processor, PhotoShop, Firefox, etc.</li><li><em>User</em>.  You.</li><li><em>Operating system.</em> Provides an environment for the application programs to do their work, and controls hardware, and coordinates its use amongst the various application programs.</li></ul><br />So, <strong>an operating system makes it so a user can more easily use applications on a computer</strong>, and also <strong>allocates the resources in the hardware</strong> to different applications.  It&#8217;s like the middle layer.<br /><br />The operating system is the one program that&#8217;s running at all times when your computer is on, also called the <strong>kernel</strong>.  (<strong>Systems programs</strong> are associated with OS too, but not the kernel, and <strong>application programs</strong> include all programs that are not associated with the operation of the system.)<br /><br /><br /><span class="sig">CPU and storage</span><br /><strong>CPUs and device controllers</strong> have access to a shared memory, and execute concurrently, competing for memory cycles.  The memory controller makes sure that their access to memory is not messed up, i.e. probably that controllers aren&#8217;t trying to access each other while they&#8217;re being used.<br /><br /><strong>A bootstrap program</strong> is the first program that a computer runs when it is turned on, and is simple, and stored in read-only memory (ROM), which is known as <strong>firmware</strong> and is stored on the computer hardware.  This intializes the system, turning on the CPU and device controllers and memory contents.  The bootstrap program is the one that loads the OS and begins executing it by loading the OS kernel into memory and letting the OS execute its first process, &#8220;init.&#8221;<br /><br /><strong>Interrupts</strong> are sent out by routines and are important because they tell the CPU to stop what it&#8217;s doing and transfer execution to the starting address of the routine.  Interrupts have to be handled quickly, so internet routines are sometimes stored in a table so that they can be called indirectly, but immediately.  This table is usually stored in low memory, and is called an <strong>interrupt vector</strong>.  An interrupt will most likely interfere with another computation that the processor was doing, so the address of that computation must be saved in a system stack, so that the CPU can return and resume later.<br /><br /><strong>Interrupt-driven</strong> refers to how most modern OS sit around and don&#8217;t do anything unless an event happens, i.e. an interrupt.  Code in the OS determine what action to take in the case of each interrupt.  An interrupt service routine is provided that is responsible for dealing with the interrupt.<br /><br /><strong>Low memory</strong> refers to the first hundred or so locations in memory.<br /><br /><strong>Random-access memory (RAM) or main memory</strong> is what stores most of the programs that are run by the CPU.  The CPU can only load instructions from memory.  RAM is implemented in a semiconductor technology called <strong>dynamic random-access memory (DRAM)</strong>.  Though it&#8217;s used to store programs, it&#8217;s usually too small to store all the needed data and programs permanently, and it&#8217;s a volatile storage device in that its contents is lost when computer power is turned off.  This is why secondary storage of memory is usually required.<br /><br /><strong>Secondary storage for memory</strong> must be able to hold large amounts of data permanently.  Example: magnetic disc, cache memory, CD-ROM, etc.<br /><br /><strong>Storage device hierarchy</strong> refers to how the high-level storage devices are fast, but expensive and volatile (like RAM, which is erased when the computer shuts off).  Highest on the pyramid are registers, the cache, and RAM; lower are the hard disk, or offline storage like magnetic tape.<br /><br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/_SdPKamJbrgg/TSZjeXlfXQI/AAAAAAAAAD0/vGkuN6HSEKU/s1600/StorageHierarchy.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="188" src="http://1.bp.blogspot.com/_SdPKamJbrgg/TSZjeXlfXQI/AAAAAAAAAD0/vGkuN6HSEKU/s320/StorageHierarchy.jpg" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">(<a href="http://www.ts.avnet.com/uk/products_and_solutions/storage/hierarchy.html">source</a>)</td></tr></tbody></table><br /><br /><strong>Read-only memory (ROM)</strong> can also store programs, but since it can&#8217;t be changed, only static programs are stored here.  ROM is where firmware is stored, and also sometimes (in the past, I guess?) lookup tables for things that don&#8217;t change, like mathematical functions.  Also, used in game cartridges!<br /><br /><strong>Von Neumann architecture</strong> describes a computer design model.  A computer with von Neumann architecture uses a CPU and a single separate storage structure (the memory) to hold both instructions and data.  The computer must also be a stored-program computer, meaning that its data and program instructions are stored in RAM.  &#8220;von Neumann architecture&#8221; and &#8220;stored-program computer&#8221; are generally used interchangeably.<br /><br /><strong>Typical instruction-execution cycle in a system with von Neumann architecture:</strong> An instruction is fetched from memory, and stored in an <strong>instruction register</strong>.  The instruction is then decoded, stored in a register, and the results may be then stored back into memory.  The running program will generate a sequence of memory addresses, which is what the memory unit sees.<br /><br /><br /><span class="sig">I/O structure</span><br /><strong>Device controllers</strong> are part of a general-purpose computer system (the other part being the CPUs), and each one is in charge of a specific type of device.  Depending on the controller, more than one device may be attached; for instance, seven or more devices can be attached to the <strong>small computer-systems interface (SCSI) controller</strong>.  They maintain local buffer storage and a set of special registers.<br /><br /><strong>Device drivers</strong> are kept by the OS, one for each device controller.  The driver provides an interface to allow the OS to interact with the device.  So you might have a device controller for a keyboard, and the driver would allow the OS to obtain the specific key presses.<br /><br /><strong>Direct-access memory (DMA)</strong> is memory that allows bulk data movement, such as input/output to/from a disk.  This makes it so that a block of data can be transferred by the device controller from its own buffer storage into the destination memory, without any help from the CPU, and it emits only one interrupt, when the operation has completed, rather than one interrupt per transferred byte.<br /><br /><br /><span class="sig">Computer-System architecture</span><br /><strong>Single-processor systems</strong> have only one general-purpose CPU capable of executing the instruction set, including instructions from user processes.  In contrast, almost all systems have separate, special-purpose (micro?) processors that are device-specific, such as a processor for the graphics controllers.  Special-purpose microprocessors don&#8217;t run user processes, don&#8217;t usually communicate with the OS (so that it can worry about its own things and go faster), and the presence of special-purpose microprocessors doesn&#8217;t turn a single-processor system into a multiprocessor system.<br /><br /><strong>Multiprocessor systems</strong> are the most common, and also called <strong>parallel systems</strong>.  These systems have two or more processors in close communication, sharing the computer bus and sometimes the clock, memory, and peripheral devices.  They have increased throughput (more processors = more work done in less time), economy of scale (more processors share peripherals, mass storage, and power supplies), and increased reliability (if work is shared between two processors, the failure of one processor will not halt the system, only slow it down).<br /><br /><strong>Graceful degradation</strong> is when a computer system can continue to provide service proportional to the level of surviving hardware.<br /><br /><strong>Fault tolerance</strong> is cooler than graceful degradation, and means that a computer system can suffer a failure to any single component and still continue to operate.<br /><br /><strong>Asymetric multiprocessing</strong> is when each processor in a multiprocessor system is assigned a specific task.  A master processor controls the system, and the other processors look to the master for instruction or have pre-defined tasks.  This is a master-slave relationship.<br /><br /><strong>Symmetric multiprocessing (SMP)</strong> is when each processor performs all tasks within the operating system, and all processors are peers to each other.  Each processor has its own set of registers, and its own local cache, though all processors share physical memory.<br /><br /><strong>Cores</strong> are essentially multiprocessor chips, which are placed on a single chip.  They can be more efficient than multiple chips with single cores because on-chip communication is faster than between-chip communication, and one chip with multiple cores will use tons less power than multiple single-core chips.  Multicore systems are good for server systems, like database and Web servers.  An example dual-core design will have a chip with two cores, each core having its own set of registers and a cache.<br /><br /><strong>Clustered systems</strong> are the same as <a href="http://nuubu.blogspot.com/2011/01/intro-to-distributed-systems.html">distributed systems</a>, I think?!  Oh, no &#8211; I guess clustered systems are made of two or more computer systems (nodes) closely linked through something like LAN, whereas a distributed system is a collection of physically separate computer systems connected by a network to &#8220;provide users with access to the various resources that the system maintains.&#8221;  More about shared resources than parallelization, I guess?  According to this book?<br /><br /><br /><span class="sig">Operating-System Structure</span><br /><strong>Multiprogramming</strong> is when different jobs (code and data) on a computer are organized so that the CPU is always executing something.  A single program can&#8217;t usually keep either the CPU or I/O devices busy at all times.  So, several jobs are kept in memory simultaneously, and whenever one program starts to wait for something (i.e. keyboard input, which it would need to continue), the CPU turns its attention elsewhere and executes another job.<br /><br /><strong>Timesharing or multitasking</strong> is an extension of multiprogramming.  In a timesharing system, a CPU will execute multiple jobs by switching between them, but users interacting with each program won&#8217;t notice since the jobs are switched so quickly.  This allows it so that multiple users can share one computer.<br /><br /><strong>A process</strong> is a program that is loaded into memory and is executing.  Usually, a process will only actually execute for a short time before it finishes or needs to perform I/O, like showing display to a user, or taking input from a keyboard.  A process is allocated resources like memory, and when the process terminates the OS will reclaim the resources.<br /><br /><strong>Job scheduling</strong> is when there are too many jobs to be all held in main memory; then the OS must choose which ones to execute.<br /><br /><strong>CPU scheduling</strong> is when several jobs are ready to run at the same time, and the system needs to choose which one to execute.<br /><br /><strong>The timer</strong> keeps user programs from being stuck in an infinite loop, which would prevent them from ever returning control to the OS.  The timer can be set to interrupt the computer after a specified period.  The operating system counts off the time.<br /><br /><span class="sig">Dual-Mode Operation</span><br />Operating systems must execute their own code, as well as user-defined code.  So, there are two modes of operation for each: <strong>user mode</strong>, and <strong>kernel mode</strong> (also called supervisor mode, system mode, or privileged mode).  A <strong>mode bit</strong> is added to the hardware of the computer to indicate whether the mode is presently kernel (0) or user (1).<br /><br />The hardware starts in kernel mode, then switches to user mode so that applications can be run.  If the user program makes a system call, the computer changes its mode back to kernel mode, does the proper stuff, and then returns to user mode before executing user code again.  This protects the OS from errant users, and errant users from one another.<br /><br />Since a user could accidentally overwrite OS code, most operating systems use this dual-mode thing.<br /><br /><br /><span class="sig">How does an OS manage memory?</span><br />Main memory is just a large array of bytes, which is quickly accessible by the CPU and I/O devices.  It&#8217;s usually the only memory that the CPU can address and access directly.  For a program to be executed, it must be mapped to absolute addresses and loaded into main memory; as it executes, it access instructions and data from the memory that was allocated to it, and when it terminates, the space it inhabited is declared available again.<br /><br />The OS has to keep track of who is using memory and how much, deciding which programs get moved in and out of memory, and allocating and deallocating memory space.<br /><br />Most programs are stored on a disk until their loaded into memory, and then use the disk as the source and destination of their processing.<br /><br />Note: It confused me for the longest time how &#8220;disk&#8221; is different from &#8220;memory.&#8221; I guess it&#8217;s just a CS distinction, since I know when people purchase &#8220;more memory&#8221; they&#8217;ll get, like, an external harddrive.  Hard disk?  I have a feeling I&#8217;ve been using all of these things interchangeably for forever.<br /><br /><br /><span class="sig">Special-purpose systems</span><br />Embedded computers are the most prevalent form of computers &#8211; they&#8217;re in car engines, DVDs, microwave ovens, etc.  They almost always run a <strong>real-time operating system</strong>, which is used when processors have to operate or data has to flow in a very rigidly defined amount of time.  If the processing is not done in the strict time constraint, it will fail.<br /><br /><br /><span class="sig">How does an OS manage file storage?</span><br />Storage media like magnetic disks, optical dicks, and magnetic tape have properties include access speed, capacity, data-transfer rate, and access method (sequential or random).  OS have to create and delete files (and their directories), support primitives for manipulating files and directories, map files onto secondary storage, and back up non-volatile storage media.<br /><br /><br /><br />Source:<br /><em>Operating System Concepts (8th Edition)</em>, Silberschatz, Galvin and Gagne, ISBN 978-0-470-12872-5.  Chapter 1.<br /><a href="http://en.wikipedia.org/wiki/Read-only_memory">Wikipedia: Read-only memory</a><br /><a href="http://en.wikipedia.org/wiki/Von_Neumann_architecture">Wikipedia: Von Neumann architecture</a></div>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">nadine a.</span></span>

      








  


<time datetime="2011-01-06T00:00:00-08:00" pubdate data-updated="true">Jan 6<span>th</span>, 2011</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/compsci/'>compsci</a>, <a class='category' href='/blog/categories/notes/'>notes</a>, <a class='category' href='/blog/categories/operating-systems/'>operating systems</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://neauro.github.io/blog/2011/01/06/operating-system-notes-chapter-1/" data-via="" data-counturl="http://neauro.github.io/blog/2011/01/06/operating-system-notes-chapter-1/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2011/01/06/avocado-tempura/" title="Previous Post: Avocado Tempura">&laquo; Avocado Tempura</a>
      
      
        <a class="basic-alignment right" href="/blog/2011/01/06/operating-systems-notes-lecture-2/" title="Next Post: Operating Systems Notes [Lecture 2]">Operating Systems Notes [Lecture 2] &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>About</h1>
  I'm Nadine. I like various things.  
</section>
<section>
  <h1>Other Places</h1>
  <ul>
    <li><a href="http://uxunicorn.com">Portfolio</a></li>
    <li><a href="http://neauro.tumblr.com">Tumblr</a></li>
    <li><a href="http://github.com/neauro">Github</a></li>
    </li>
  </ul>
</section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - nadine a. -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
