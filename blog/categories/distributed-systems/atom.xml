<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Distributed Systems | liwanag]]></title>
  <link href="http://blog.neauro.com/blog/categories/distributed-systems/atom.xml" rel="self"/>
  <link href="http://blog.neauro.com/"/>
  <updated>2014-02-18T10:18:09-08:00</updated>
  <id>http://blog.neauro.com/</id>
  <author>
    <name><![CDATA[nadine a.]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Remote Procedure Calls (RPC)]]></title>
    <link href="http://blog.neauro.com/blog/2011/01/04/remote-procedure-calls-rpc/"/>
    <updated>2011-01-04T00:00:00-08:00</updated>
    <id>http://blog.neauro.com/blog/2011/01/04/remote-procedure-calls-rpc</id>
    <content type="html"><![CDATA[<div class='post'>
<span class="sig">What is a remote procedure call (RPC)?</span><br />RPC is a paradigm for providing communication across a network between programs written in a high-level language.  "Procedure calls" in general are a well-known and well-understood way of transferring control and data within a program on a single computer -- a program calls a procedure, giving it certain arguments, and receives some output from the procedure back.  So, a remote procedure call -- when a program calls a procedure that is not necessarily on the same system that the program is on -- should be workable as well.<br /><br />An RPC "cycle" goes like this:<br /><ol><li>A remote procedure is invoked by a caller, who passes the procedure parameters</li><li>The caller's environment is suspended as it waits for a response</li><li>The parameters are passed across the network to the environment where the procedure will execute</li><li>The desired procedure is executed</li><li>When the procedure finishes executing, the results are passed back to the calling environment</li><li>The caller's environment resumes with the new data (or else fails, I assume, because of a timeout...though the "Implemented remote procedure calls" didn't use timeouts, since single-machine systems don't)</li></ol><br /><br /><span class="sig">What are the advantages of RPC?</span><br /><ol><li><strong>Clean and simple semantics.</strong>  <a href="http://nuubu.blogspot.com/2011/01/intro-to-distributed-systems.html">Distributed systems</a> are complicated because communication throughout one is complicated, so simplicity is good.</li><li><strong>Simplicity.</strong>  Which means it's probably fast.</li><li><strong>Generality.</strong>  Procedure calls work in single-machine systems, besides being usable in distributed systems.</li></ol><br /><br /><span class="sig">What are the disadvantages of RPC?</span><br />There are some design issues --<br /><ul><li>What semantics do you use when the machine fails, or when communication fails?</li><li>What are the semantics when a caller does something address-specific, and the caller and callee don't have a shared address space?</li><li>How do you integrate RPC into existing/future programming systems?</li><li>How does a caller figure out the location and identity of the procedure it wants?</li><li>What's a suitable protocol for the transfer of data?</li><li>How do you provide data integrity and security in an open communication network?</li></ul><br /><br /><span class="sig">Really general implementation</span><br />The structure of RPC is based on the concept of <em>stubs</em>; the parts of the program involved in an RPC (the user, the user-stub, the RPC communications package, the server-stub, and the server) are all executed on their respective places, and when a user wants to use an RPC, it really just calls its user-stub, which is what makes the RPC.  This way, specifying the target procedure and the arguments is sent in a "call packet" to the server-side stuff, which is handled similarly: the server-stub unpacks the packet, makes a local call to the procedure on the server, and packs it up again in a "result packet" to be sent to the caller.  This serves to encapsulate everything (I think?).<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/_SdPKamJbrgg/TSPV2_29a7I/AAAAAAAAADs/WoPFIW0-3zM/s1600/rpc%2Bstubs.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="161" src="http://2.bp.blogspot.com/_SdPKamJbrgg/TSPV2_29a7I/AAAAAAAAADs/WoPFIW0-3zM/s320/rpc%2Bstubs.jpg" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">from "Implementing Remote Procedure Calls"</td></tr></tbody></table><br />The RPCRuntime handles the actual handling-off between the user-stub and the server-stub.<br /><br />The semantics of RPCs can also be handled without needing a specialized packet-level protocol.  <br /><br /><br /><span class="sig">Other notes:</span><br /><ul><li>RPC is supposed to make distributed computation more easy; in the "Implementing Remote Procedure Calls" paper, the authors hoped to solve the difficulty of distributed systems communication and leave only the problems of timing, independent failure of components, and the coexistence of independent execution environments.</li></ul><br /><br />Source:<br /><a href="http://portal.acm.org/citation.cfm?id=357392">Andrew Birrell and Bruce Nelson. Implementing Remote Procedure Calls. ACM TOCS 1984.</a></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intro to Distributed Systems]]></title>
    <link href="http://blog.neauro.com/blog/2011/01/04/intro-to-distributed-systems/"/>
    <updated>2011-01-04T00:00:00-08:00</updated>
    <id>http://blog.neauro.com/blog/2011/01/04/intro-to-distributed-systems</id>
    <content type="html"><![CDATA[<div class='post'>
So, for now at least, I'm taking a class on distributed systems.  <a href="http://code.google.com/edu/parallel/dsd-tutorial.html">Google</a> has a good tutorial on what a distributed system is, which I will take notes from/copy shamelessly.<br /><br />Firstly, definitions --<br /><strong>A protocol</strong> is "a formal description of message formats and the rules that two processes must follow in order to exchange those messages."<br /><br /><strong>A network</strong> is "the infrastructure that links computers, workstations, terminals, servers, etc.  It consists of routers which are connected by communiation links."<br /><br /><strong>A distributed system</strong> is "an application that executes a collection of protocols to coordinate the actions of multiple processes on a network, such that all components cooperate together to form a single or small set of related tasks."<br /><br />My impression of it currently is also like this: a distributed system is a program that controls a ton of computers and with their powers combined accomplishes great things, like searching the internets for that picture of Maru wearing a crab hat.<br /><br /><br /><span class="sig">Advantages of a distributed system:</span> <br />Distributed systems can connect remote users with remote resources in an open and scalable way.  <em>Open</em> meaning that each component of the system can interact with other components at any time, <em>scalable</em> meaning that the system can be easily altered to accomodate changes in the amount of users or resources.<br /><br /><br /><span class="sig">Disadvantages of a distributed system:</span><br />A system of things working together is more complicated than a system of something working by itself.  An example of this is an airplane with two engines, which spend much more time on the ground than airplanes with a single engine, simply because planes cannot take off if anything is wrong with them, and there's more to go wrong with an airplane that has more engines.<br /><br />Distributed systems have a lot of complexity because its components, the computers or servers or etc., have to interact properly.  An example of how difficuult the interaction can be can be found with the <strong>two generals problem</strong>, which goes like this:<br /><br /><blockquote>Two generals on opposite hillsides want to coordinate an attack.  General A sends a message -- "Let's attack at dawn!" -- to General B.  How will General A know if General B agrees?  B will send a message in response -- "Alright, let's attack at dawn!" But then how will B know that A received his confirmation?  A will have to send a message back.  And then how will A know that B got the confirmation message?  B will have to send a message back...</blockquote><br />And so on and so forth.<br /><br /><br /><span class="sig">So, a well-designed distributed system will have these characteristics:</span><br /><ol><li>Fault-tolerant: if a components fails, it can recover without performing incorrect actions</li><li>Highly available: if a component fails, it can restore operations and continue to provide services</li><li>Recoverable: if a component fails, it can restart itself and rejoin the system after failure has been fixed</li><li>Consistent: in the event of failure, a system can still coordinate components</li><li>Scalable: if some aspect of the system is scaled to a larger size (i.e. if there are more users, or size of network increases), then the system can still work correctly</li><li>Predictable performance: the system can provide responsiveness in a timely fashion</li><li>Secure: the system can authenticate access to data and services</li></ol><br />With distributed systems, you have to <em>design for failure</em>.  If I told you to do something and you didn't do it, is it because I didn't tell you clearly what to do?  Or is it because you didn't see me tell you?  Or is it because I didn't get confirmation that you had done it?  This problem is the reason why distributed systems are so hard to debug -- it's hard to see where exactly the problem originated, or why it happened.<br /><br /><br /><span class="sig">Distributed systems design</span><br />Firstly, about client-server applications.  They work by having a <em>server</em> which provides some service, like processing database queries, and a <em>client</em> which uses the service, i.e. to show the database query results.  Different types of servers do different things: for instance, a database server houses databases and allows clients to access them, file servers manage disk storage, etc.  The communication between client and server needs to be reliable.<br /><br />Reliability is governed by protocols, like TCP/IP.  The Internet Protocol (IP) is a set of communication protocols that allow for communication on the internet and most commercial networks.  The Transmission Control Protocol (TCP) is a core part of IP, and allows clients and servers to create connections to one another and exchange data in "packets." Protocol guarantees reliable and in-order delivery of data from sender to receiver.<br /><br />With a distributed system, there can be many types of servers, and <em>service</em> is a term that refers to a set of servers of a particular type.  "Binding" is when a process that needs to access a service becomes associated with a particular server which provides the service.  Programs which which server to associate with through binding policies.  For example, someone looking for certain information on a database may be connected to a server which is closest to them geographically, so that access is faster, or he or she may be connected to a database which has the least number of people presently accessing it.<br /><br />To keep things reliable, a distributed service may keep multiple copies of data so you can still access it if something goes wrong.  To keep things going fast, a distributed service may <em>cache</em> data, which is when it makes copies of the data and keeps a copy of it locally, so the data can be accessed quickly the next time it's wanted.  <br /><br /><br /><span class="sig">More about TCP/IP</span><br />The IP "suite" can be viewed as a set of layers, in which each layer uses the functions of the layers below it and gives functionality to the layer above it.  The lower layers are typically implemented in hardware, whereas the higher layers are implemented in software.<br /><br />The layers:<br /><ol><li>Application layer: is used by most programs that require netwrok communication.  The program gives data to this layer of protocol, and then encapsulated in a transport layer protocol.  Examples of applications that use this layer: HTTP, FTP. </li><li>Transport layer: is responsible for end-to-end message transfer, along with error control, fragmentation, and flow control.  End-to-end message transmission can be categorized as <em>connection-oriented</em> (TCP) or <em>connectionless</em> (UDP), with TCP being the more sophisticated and reliable.<br /></li><ul><li>TCP works by: first, ensuring the receiving computer is ready to accept data by using a "three-packet handshake" in which the sender and receiver agree they're ready to communicate.  Then, TCP makes sure data gets to its destination.  If the receiver doesn't acknowledge a packet of the data, TCP will automatically transmit the packet three times, and also split the large packet into smaller ones if needed so that the data can travel more reliably.  TCP will also drop duplicate packets and rearrange the ones that arrive out of sequence.</li><li>Note for self: What's the relationship between this and torrenting something?  Also, I understand that TCP is a protocol, which means that it's a "formal description," so what's with this "TCP making sure data reaches" and "TCP automatically transmitting" stuff as if it's a program which does something?</li></ul><li>Network layer: solves the problem of getting packets across a single network, or, getting packets from one network to another network by moving the packet across a network of networks, i.e. the Internets.  IP performs the basic task of getting packets of data from source to destination.</li><li>Link layer: deals with the physical transmission of data, i.e. placing frame headers and trailers on packets for travelling over the physical network, and dealing with physical components.</li></ol><br /><br /><span class="sig">Remote Procedure Calls (RPCs)</span><br />A remote procedure call (RPC) is another method besides TCP/IP that clients can use to interact with servers.  It's based off the idea that the procedure that a client wants to use may not be in the same "address space," i.e. the procedure is off on a different system with a network connecting them.<br /><br />So, when an RCP is made, the arguments are passed to a remote procedure and the caller waits for a response or a timeout.  Each incoming request to a server usually spawns a new thread, and a thread in the client issues an RPC and then waits, and resumes execution when it receives a reply.<br /><br />RPC-based code needs to do three things:<br /><ol><li>Specify the protocol for client-server communication</li><ul><li>The protocol is created by <em>stubs</em>, which are generated by a protocol compiler.  A stub is a routine that doesn't do much other than to declare itself and the parameters it accepts -- just enough to allow it to be compiled and linked.</li></ul><li>Develop the client program, which will call the remote procedure, pass it the required data, and receive returned data</li><li>Develop the server program, which will register the procedures that may be called by a client, and receive/return data required for processing.</li></ol><br />So, an RPC application uses classes made by the stub generator to execute an RPC, and then wait for it to finish.<br /><br />Some errors that may happen in RPC programming are binding errors, which will happen when a server isn't running when a client is started); or version mismatches, if a client compiled against an outdated version of the server.  Timeouts will occur in the case of a server crash, network problem, or client computer problem.<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/_SdPKamJbrgg/TSN28QczM5I/AAAAAAAAADc/gDZxppbry4c/s1600/DSC_1015.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="240" src="http://2.bp.blogspot.com/_SdPKamJbrgg/TSN28QczM5I/AAAAAAAAADc/gDZxppbry4c/s320/DSC_1015.jpg" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">(<a href="http://sisinmaru.blog17.fc2.com/blog-entry-47.html">source</a>)</td></tr></tbody></table><br />Sources:<br /><a href="http://code.google.com/edu/parallel/dsd-tutorial.html">Google: Introduction to Distributed System Design</a><br />Lecture notes</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Developing Protocol Buffers]]></title>
    <link href="http://blog.neauro.com/blog/2011/01/04/developing-protocol-buffers/"/>
    <updated>2011-01-04T00:00:00-08:00</updated>
    <id>http://blog.neauro.com/blog/2011/01/04/developing-protocol-buffers</id>
    <content type="html"><![CDATA[<div class='post'>
Again taken from <a href="http://code.google.com/apis/protocolbuffers/docs/overview.html">t3h googs</a>, who developed protocol buffers in the first place.<br /><br /><br /><span class="sig">What are protocol buffers?</span><br />Protocol buffers are a "flexible, efficient, automated mechanism for serializing structured data" -- like XML but smaller, faster, simpler.  In this case, I assume that "serializing data" refers to converting some data structure into an object that can be stored and then unpacked again into another computer environment, i.e. storing a list into a file or something so it can be sent over a network and then opened up again and read by someone else.  So, a protocol buffer provides a way for data to be moved across multiple computers, which explains why it's relevant to <a href="http://nuubu.blogspot.com/2011/01/intro-to-distributed-systems.html">distributed systems</a>.<br /><br /><br /><span class="sig">How do protocol buffers work?</span><br />You have data, and you want to serialize it so that you can trasmit it to another network or computer in a message.  To specify how you want to serialize it, you have to <strong>define protocol buffer message types in <code>.proto</code> files</strong>.  Each protocol buffer message is a small, logical record of information with a series of name-value pairs.  A <code>.proto</code> file which defines a message containing information about a Pokemon would be like this:<br /><br /><pre class="brush: js">message Pokemon {<br />    required string species = 1;<br />    required int32 id = 2;<br />    optional string trainer = 3;<br />    optional string nickname = 4;<br /><br />    enum Type1 {<br />        FIRE = 0;<br />        WATER = 1;<br />        GRASS = 2;<br />    }<br />}       <br /></pre><br />So in this case, I've got a message that serializes data about a Pokemon.  The message contains information about a Pokemon, its trainer, its id, its nickname, and its type.  For a message to be a well-formed Pokemon message, it must contain exactly one of <code>species</code> and <code>id</code>, but can have zero or exactly one of <code>trainer</code> or <code>nickname</code>.  The <code>enum</code> means that the Pokemon will have only one of a predefined list of values -- that is, only one type out of the three given types.<br /><br />Once the messages have been defined, they're run against whatever protocol buffer compiler you have for your application's language, which will generate <strong>data access classes</strong>.  These will provide a way to access each field defined in the message.  So, if you were using C++, the data access class created would be called <code>Pokemon</code>, and you could then use this <code>Pokemon</code> class to populate, serialize, and retrieve <code>Pokemon</code> protocol buffer messages.  Then you send out the message like,<br /><br /><pre class="brush:cpp">Pokemon pokemon;<br />pokemon.set_species("Charmander");<br />pokemon.set_id(4);<br />pokemon.set_trainer("Red");<br />fstream output("file", ios::out | ios::binary);<br />pokemon.SerializeToOsteam(&amp;output);<br /></pre><br />and read it like,<br /><br /><pre class="brush:cpp">fstream input("file", ios::in | ios:: binary);<br />Pokemon pokemon;<br />pokemon.ParseFromIsteam(&amp;input);<br />cout &lt;&lt; "Pokemon: " &lt;&lt; pokemon.species() &lt;&lt; endl;<br />cout &lt;&lt; "Trainer: " &lt;&lt; pokemon.trainer() &lt;&lt; endl;<br /></pre><br /><span class="sig">What are the advantages of protocol buffers?</span><br /><ul><li>You can add new fields to message formats without breaking backwards-compatibility; old binaries will just ignore the new field.  So, extending the protocol is simple, and you can do it without having to worry about breaking existing code.</li><li>It's simpler, smaller, faster, and less ambiguous than XML.  Plus, it generates the data access classes, which are easier to use in programs.  I imagine that XML takes so much space and is harder to parse because you have to close tags.  Also, to manipulate XML you'd have to do things like finding a node "species" and then accessing its inner text, instead of just retrieving "species" immediately.</li></ul><br />Sources:<br /><a href="http://code.google.com/apis/protocolbuffers/docs/overview.html">Google: Protocol Buffers Developer Guide</a><br /><a href="http://en.wikipedia.org/wiki/Serialize">Wikipedia: Serialization</a><br /><a href="http://code.google.com/apis/protocolbuffers/docs/proto.html#enum">Google: Protocol Buffers Language Guide</a></div>

]]></content>
  </entry>
  
</feed>
